//-------------------------------------------------

MODELNAME = "CFM56-7B27";

//-------------------------------------------------
// How to run
//-------------------------------------------------
// - This model is called by cdm01_tf02.run
// - However, this model can also be run independently by using -I flags
// - The -I flags specify the location of directories for the custom elements,
//   turbine maps, and compressor maps
// - The -I flag enables NPSS to search in the subsequent directory for files
// - In order to run cdm01_tf02.mdl independent of a run file, enter the
//   following into a NPSS command environment:
//		   >> runnpss cdm01_tf02.mdl -I ../src -I ../data

//-------------------------------------------------
// Set thermodynamic package
//-------------------------------------------------
// #ifndef THERMO
// 	#define THERMO GasTbl
// #endif

// setThermoPackage("$THERMO");
// setThermoPackage("Janaf");
// setThermoPackage("allFuel");
// setThermoPackage( "CEA", "thermo.inp", "trans.inp", "Air", "H2O", "Jet-A(g)" );

//-------------------------------------------------
// Functions & Tables
//-------------------------------------------------
#include "ESI.fnc"
#include "schedules.tabl"

// ------------------------------------------------
// Option Variables
// ------------------------------------------------
// Option switchDes {
// 	description = "Determines if the overall model is in design or off-design mode";
// 	IOstatus = "input";
// 	rewritableValues = FALSE;
// 	trigger = FALSE;
// 	allowedValues = {"DESIGN","OFFDESIGN"};
// }


Assembly Assembly Eng
{
	// 1. Assembly level elements for solution control, interfacing, and power setting
	Option switchDes {
		description = "Determines if the engine assembly is in design or off-design mode";
		IOstatus = "input";
		rewritableValues = FALSE;
		trigger = TRUE;
		allowedValues = {"DESIGN","OFFDESIGN"};
	}
    // Element EngInterface Eint
    // {
    //     description = "Engine Interface";
    // }

    // Element PowerSetting Pset
    // {
    //     description = "Power Settings";
    //     setOption("switchParm", "THRUST");
    //     setOption("switchLimitSet","NONE");
    //     parm_in = 40000.0;

    //     Table TB_SKED( real PL ) 
	// 	// This is the schedule for the Powersetting element - here it 
	// 	// sets the value of the low spool relative corrected speed.
    //     {
	// 		PL =      {0, 10, 25, 50, 75, 100, 150}
    //         PC_SKED = {0, 70, 80, 90, 95, 100, 150}
    //     }
    //     TB_SKED.extrap = "none";
	// 	TB_SKED.interp = "linear";
    // }

	// 2. Free Stream definition - establish ambient conditions
    // ------------------------------
    // Ambient Amb
    // ------------------------------
    Element Ambient Amb
    {
        setOption( "switchMode", "ALDTMN" );
        setOption( "switchDay" , "STD" );
        alt_in    = 0.0 "ft";
        dTs_in    = 0.0 "dF";
        MN_in     = 0.0;
    }
    // ------------------------------
    // InletStart FsEng
    // ------------------------------
    Element InletStart FsEng
    {
        AmbientName = "Amb";
        setOption("switchInd" , "W");
        W_in = 200.0;
		real theta_0;
		void postexecute(){
			theta_0 = Fl_O.Tt/518.67;
		}
    }
    // 3. Front Face definition - inlet drag losses and flow splitting
	// ------------------------------
    // Inlet InEng
    // ------------------------------
    Element Inlet InEng
    {

		// ASK: Should PqP_in be set to 0.998 or use table?? also, MNdes??
		Fl_O.MNdes = 0.6677;
		// PqP_in = 0.998;	
		
		Table Inlet_PqP_map (real MN, real W2R)
		{
			MN = 0.
			{
				W2R = { 600., 700., 800.}
				PqP = { 0.99, 0.99, 0.98}
			}
			MN = 1.2
			{
				W2R = { 600., 700., 800.}
				PqP = { 0.99, 0.99, 0.98}
			}
		}
		
	// 	void preexecute()
	// 	{   if (Amb.MN_in > 1)
	// 		{
	// 		PqP_in = 1 - 0.075*(Amb.MN_in - 1)**1.35;
	// 		// Based on the MIL - E-5008B specification
	// 		// Taken from PropulsionAndPower by Kurzke
	// 		}
	// 		else
	// 		{
	// 			PqP_in = 0.999;
	// 		}
	// 	}
	}
	// ------------------------------
    // Inlet Drag CdragIn
    // ------------------------------
	// Element CustomerDrag CdragIn{description = "Placeholder Inlet Spillage Drag";}
	// ------------------------------
	// Compressor CmpF
	// ------------------------------
	Element Compressor CmpF
	{
		PRdes  = 1.685;
		effDes = 0.8948;
		#include "fanCFM56.map"
		// Sh_O.inertia = 10.;     // slugs-ft**2.

		real dia {value = 0; units = "in";}
        real dT, Ts, Rs, a, Vtip;
        real HTRf, Mtip; // Hub-tip ratio and Mtip
        HTRf = 0.3;
		void postexecute()
		{
			dia	= (Fl_I.Aphy*4.0/3.1415/(1.0-HTRf**2))**0.5;

			dT = (Fl_O.Tt - Fl_I.Tt)*100/180; //temp diff in K

            Ts = Fl_I.Ts * 100/180;
            Rs = Fl_I.Rs *getUnitsFactor(Fl_I.Rs.units, "J/(kg*K)");

            a  = sqrt(Fl_I.gams * Ts *Rs);
            Vtip = 2.0*PI*Nmech/60.0 * dia/2.0 * getUnitsFactor(dia.units, "m");
            Mtip = sqrt((Vtip/a)**2.0 + Fl_I.MN**2.0);
		}

		// ASK: This equation originally had HTR set to 0.34
		// real fan_dia = (Fl_I.Aphy*4/3.1415/(1-0.34**2))**0.5;

		// ASK: should this be 0.3??
		Fl_O.MNdes = 0.4197;
		
		//Use an indep var to iterate adiabatic eff to get a desired poly eff.
		// Independent ind_CmpF_eff { varName = "effDes";}
	}	
    // ------------------------------
    // Splitter SpltFan
    // ------------------------------
    Element Splitter SpltFan
    {

		// ASK: This seems very low... set to 15?
        BPRdes = 5.12;
        Fl_O1.MNdes = 0.3107;
        Fl_O2.MNdes = 0.4522;
    }
	//--------------------------

	// ASK: What is this duct??
	Element Duct D01
    {
        switchDP = "INPUT";

        void preexecute()
        {
            dPqP_in = 0.0048;//0.12 * Fl_I.MN * Fl_I.MN;
        }

        
		Fl_O.MNdes = 0.3121;
    }
    // ------------------------------
    // Compressor CmpFPri
    // ------------------------------
    Element Compressor CmpL
    {
		// #include "lpcE3.map"
		// #include "lpcE3_linear.map"
		// #include "lpcCFM56.map"
		#include "lpcCFM56_prash_new.map"
		// #include "lpcCFM56_prash.map"
		// #include "lpcCFM56_linear.map"
		
		// ASK: values of PR, eff, and MN
		PRdes  = 1.935;
        effDes = 0.9243;

        // real dlcomp, HTRlc;
		// HTRlc = 0.6;

		// void postexecute()
		// {
		// 	dlcomp = ((4.0*Fl_I.Aphy)/(3.1415*(1.0-HTRlc**2.0)))**0.5;

		// }

		// Sh_O.inertia = 10.;     // slugs-ft**2.
		// Independent ind_CmpL_eff { varName = "effDes";}
		Fl_O.MNdes = 0.3059;
    }
	// ------------------------------
    // Duct HPC Transition
    // ------------------------------
    Element Duct D021
    {
        switchDP = "INPUT";

		// ASK: again, values of dPqP_in and MNdes

        void preexecute()
        {
            dPqP_in = 0.0101;//0.12 * Fl_I.MN * Fl_I.MN;
        }

        
		Fl_O.MNdes = 0.3563;
    }
	
	// ------------------------------
	// Include Common CFM56- Core
	// ------------------------------
	// #include <Core.mdl>
	// ------------------------------
    // Compressor CmpH
    // ------------------------------
    Element Compressor CmpH
    {
		// ASK: Why does the TEsys include S_map values??
		PRdes    = 9.369;
		effDes   = 0.8723;
		// Sh_O.inertia   = 10.;     // slugs-ft**2.
		// #include "hpcCFM56_2.map"
		// #include "hpcCFM56.map"
		#include "hpcCFM56_linear.map"
		
		// Independent ind_CmpH_eff { varName = "effDes";}
		

		// ASK: what are these bleedout ports??
		InterStageBleedOutPort  Fl_B_CH
		{
			//switchFlow = "ABSOLUTE"
			fracBldWork	= 0.5;
			fracBldP = 0.5;
			fracBldW = 0.020274;
		}		
		InterStageBleedOutPort  Fl_B_NC
		{
			//switchFlow = "ABSOLUTE";
			fracBldWork	= 0.5;
			fracBldP = 0.5;
			fracBldW = 0.050708;
		}	
		
		// Customer Interstage HPC bleed
		InterStageBleedOutPort  Fl_B027
		{
			//switchFlow = "ABSOLUTE";
			fracBldWork	= 0.5;
			fracBldP = 0.5;
			// Wbld = 2.35;
			
		}
		Fl_O.MNdes = 0.25;
    }

    // ------------------------------
    // Bleed B030
    // ------------------------------
    Element Bleed B030
    {

		// ASK: why is the chargeable port not 0 in this case, but is 0 in TE??
		// Turbine Cooling and Leakage Air (TCLA) stream 1 
		// conisdered NON CHARGEABLE (connects to turbine inlet)
		BleedOutPort TCLA_NC {	              
			fracW = 0.1675;  //fracW = Ratio of bleed flow to Bleed element inlet flow
		}	
		// Turbine Cooling and Leakage Air (TCLA) stream 2 
		//considered CHARGEABLE (connects to turbine exit)
		BleedOutPort TCLA_CH {	              
			fracW = 0.100; //fracW = Ratio of bleed flow to Bleed element inlet flow
		} 

// ASK: What is this??
		BleedOutPort Fl_B030B
        {
            hscale = 1.0;
            fracW = 0.0;
        }
		Fl_O.MNdes = 0.3;
    }
    // ------------------------------
    // Duct Diffuser
    // ------------------------------
    
	// ASK: why is there a duct here but not in the TEsys??
		// why is dPqP not specified??
	Element Duct D031
    {

        Fl_O.MNdes = 0.3;
    }
    // ------------------------------
    // FuelStart FusEng
    // ------------------------------
    Element FuelStart FusEng
    {
		// fuelType = "Jet-A(L)";
		// Wfuel = 1.4;
		Wfuel = 0.09 * 120 * 430/LHV;
	
		 // ------------GasTab------------
		//  if( THERMPACKAGE == "GasTbl")
		//  {
		// 	cout<<"------------------------"<<endl;	
		// 	cout<<"Using "<<THERMPACKAGE<<endl;
		// 	cout<<"------------------------"<<endl;
		// 	LHV_in = 18700;//18384;//  // 1MJ/kg = 429.923 BTU/lbm 18700.0;
		// 	// Tref = 536.67; // 518.67 (59 F) if GASTAB, 536.67 (77 F) otherwise
		// 	// hFuel = 10;
		// 	setOption("switchGasTblOpt", "GASEQL2");
		// 	//setOption("switchGasTblOpt", "GASTAB");
		//  }
		//  //------------------------------	 
		//  // ------------JANAF------------
		//  if( THERMPACKAGE == "Janaf")
		//  {
		// 	cout<<"------------------------"<<endl;	
		// 	cout<<"Using "<<THERMPACKAGE<<endl;
		// 	cout<<"------------------------"<<endl;
		// 	LHV_in = 18700;
		// 	Carbon = 1.;
		// 	Hydrogen = .15598;
		// 	hFuel = .481*( 536.67 - 529.67 );
		//  }
		//  //------------------------------
		//  // ------------C E A------------
		//  if( THERMPACKAGE == "CEA")
		//  {
		// 	cout<<"------------------------"<<endl;	
		// 	cout<<"Using "<<THERMPACKAGE<<endl;
		// 	cout<<"------------------------"<<endl;
		// 	fuelType = "Jet-A(g)";
		// 	hFuel = -699.4;
		//  }
		 //------------------------------
		
        // HERE IS WHERE THE INDP Variable is set.		
        // Independent ind_Wfuel { varName = "Wfuel";}// autoSetup = TRUE;}

    }
    // ------------------------------
    // Burner BrnPri
    // ------------------------------
    Element Burner BrnPri
    {
        dPqP_dmd     = 0.054;
        effBase      = 1.;//0.99;
        setOption("switchBurn", "WFUEL");
		Fl_O.MNdes = 0.1;

		real EINOx = 0;

		void postexecute(){
			// Calcualte EINOx based on P3T3 method calibrated to CFM56-5B
			real T3 = Fl_I.Tt*100/180;
			real P3 = Fl_I.Pt*getUnitsFactor(Fl_I.Pt.units, "kPa");

			real a,b,c,d;
			a = 6.25528852e-08;
			b = -1.17064467e-04;
			c = 7.36953400e-02;
			d = -1.50392850e+01;
			EINOx = P3**0.4*(a*T3**3 + b*T3**2 + c*T3 +d)*FusEng.LHV/18400; //this applies a scaling if different fuels are used

		}

    }
    // ------------------------------
    // Turbine TrbH
    // ------------------------------
    Element Turbine TrbH
    {

		// ASK: again, why different PR and eff vals??
		// Why is MNdes not set??
		
		PRbase       = 3;
		effDes       = 0.888;
		#include <hptCFM56.map>
		a_effAud = 0.0;		
		//setOption("switchAud", "AUDIT");
		
		FlowStation F041;
		// Turbine Cooling and Leakage Air (TCLA) stream 1 
		// (introduced at turbine inlet)
		InterStageBleedInPort TCLA_NC { 
			Pfract  = 1.0;
			diaPump = 0.0;
		} 
		
		// Turbine Cooling and Leakage Air (TCLA) stream 2 
		// (introduced at turbine exit)
		InterStageBleedInPort TCLA_CH { 
			Pfract  = 0.0;
			diaPump = 0.0;
		}
		
		// Subelement to calculate the amount of cooling flow required to cool the turbine	
		Subelement CoolIt Cool 
		{
			nStages = 1;
			bldNameFirstRow = "TCLA_NC";
			bldName = "TCLA_CH";
			TvaneDes[0] = 2000;
			TbladeDes[0] = 1900;
			s_BldFirstRow = 1.4;  
			s_Bld = 1.4;  
		}   

		void postexecute() 
		{ 
			F041.copyFlow("Fl_I");
			F041.add("TCLA_NC");
			if ( switchDes == "DESIGN" ) 
			{
				Cool.run();
			}
		}
	}
	// ------------------------------
	// End of Cust Bleed interstage
	// ------------------------------
	Element FlowEnd FeOBA
	{
	}
	// ------------------------------
	// End of Cust Bleed B
	// ------------------------------
	Element FlowEnd FeOBB
	{
	}	
	// ------------------------------
	// Shaft ShH
	// ------------------------------
	Element Shaft ShH
	{
		ShaftInputPort CmpH, TrbH;
		// ShaftOutputPort	PowerExtract;
		// Nmech = 15183.0;
		Nmech = 9000.0;
		// inertia = 10.0;
		// HPX = 550;
	}	
	// ------------------------------
	
	
	// ------------------------------
	// Duct D043
	// ------------------------------
	Element  Duct D043{
		Fl_I.MNdes = 0.24;
		
		switchDP = "INPUT";

        void preexecute()
        {
        	dPqP_in = 0.0051;//0.1 * Fl_I.MN * Fl_I.MN;
        }

		
		Fl_O.MNdes = 0.35;}
	// ------------------------------
	// Turbine TrbL
	// ------------------------------
	Element Turbine TrbL
	{

		PRbase     = 6.0;
		effDes     = 0.875;
		#include "lpt_CFM56_3.map"
		//setOption("switchAud", "AUDIT");
		
		InterStageBleedInPort TCLA_NC { 
			Pfract  = 1.0;
			diaPump = 0.0;
		} 
		
		// Turbine Cooling and Leakage Air (TCLA) stream 2 
		// (introduced at turbine exit)
		InterStageBleedInPort TCLA_CH { 
			Pfract  = 0.0;
			diaPump = 0.0;
		}
		
		// Can potentially calcualte this based on metal temp
		// // Subelement to calculate the amount of cooling flow required to cool the turbine	
		// Subelement CoolIt Cool 
		// {
			// nStages = 1;
			// bldNameFirstRow = "TCLA_NC";
			// bldName = "TCLA_CH";
			// TvaneDes[0] = 2100;
			// TbladeDes[0] = 1900;
			// s_BldFirstRow = 1.4;  
			// s_Bld = 1.1;  
		// }   

		// void postexecute() 
		// { 
			// F041.copyFlow("Fl_I");
			// F041.add("TCLA_NC");
			// if ( switchDes == "DESIGN" ) 
			// {
				// Cool.run();
			// }
		// }
		Fl_O.MNdes = 0.4;
	}
	// ------------------------------
	// Bleed B050
	// ------------------------------
	Element Bleed B050{BleedInPort Fl_B050;}
	// ------------------------------
	// Duct D06 MixHOT
	// ------------------------------
	Element Duct D060
	{
		switchDP = "INPUT";

		void preexecute()
		{
			dPqP_in = 0.0107;//0.1 * Fl_I.MN * Fl_I.MN;
		}

		Fl_I.MNdes = 0.31;
		Fl_O.MNdes = 0.31;
	}
	// 5. Bypass Stream definition - Fan and duct
	// ------------------------------
	// Duct OGV
	// ------------------------------
	Element Duct D130
	{
		switchDP = "INPUT";

		void preexecute()
		{
			// ASK: why is this 0?? 
			dPqP_in = 0.0;//0.1 * Fl_I.MN * Fl_I.MN;
		}
		Fl_O.MNdes = 0.4;
	}
	// ------------------------------
	// Bleed B125
	// ------------------------------
	Element Bleed B130
	{
		BleedOutPort Fl_B130
		{
			hscale = 1.0;
			fracW = 0.005;
		}
	}
	// ------------------------------
	// Duct D160 MixCold
	// ------------------------------
	Element Duct D160
	{
		switchDP = "INPUT";

		void preexecute()
		{
			dPqP_in = 0.0149;//0.2 * Fl_I.MN * Fl_I.MN;
		}
		Fl_I.MNdes = 0.3;
		Fl_O.MNdes = 0.45;
	}
	// ------------------------------
	// Nozzle NozPri
	// ------------------------------
	Element Nozzle NozPri
	{
		PsExhName = "Amb.Ps";
		switchType = "CONIC";
		switchCoef = "CV";
		Cv_in = 0.99;
		// switchCoef = "CFG";
		// switchCdTh = "INPUT";
		// PR = 2.0;
		// CdTh_in = 1.00;
		// Cfg_in  = 0.985;
	}
	// ------------------------------
	// Nozzle NozSec
	// ------------------------------
	Element Nozzle NozSec
	{
		PsExhName = "Amb.Ps";
		switchType = "CONIC";
	    switchCoef = "CV";
		Cv_in = 0.993;
		// switchCdTh = "INPUT";
		// PR = 2.0;
		// CdTh_in = 1.00;
		// Cfg_in  = 0.985;
	}
	// ------------------------------
	// Nozzle Drag
	// ------------------------------

	// ASK: what is this for???
	// Element CustomerDrag CdragNoz{description = "Placeholder for Nozzle Drag";}
	// ------------------------------
	// Exhaust Flow End
	// ------------------------------
	Element FlowEnd FePri
	{
		//BleedInPort Fl_CbldEnd;
	}
	// ------------------------------
	// Exhaust Flow End
	// ------------------------------
	Element FlowEnd FeSec{}
	// 7. Shaft definition - HP and LP shafts
	// ------------------------------
	// Shaft ShL
	// ------------------------------
	Element Shaft ShL
	{
		ShaftInputPort CmpL, CmpF, TrbL;
		Nmech = 3500.0;
		// inertia = 13.0;
	}

	// ASK: Why is there no ShF on this one???


	// ASK: Just make sure these performance calculations are not what I need.
	// // 8. Performance calculations
	
	// // ------------------------------
	// // EngPerf PERF
	// // ------------------------------
	// Element EngPerf Perf{
	// 	// ------ THERMAL EFFICIENCY ------------------
	// 	/*
		
	// 	// Ideal thermal efficiency
	// 	The Ideal thermal efficiency of this cycle is defined as the ideal amount
	// 	of work that can be extracted from the flow after the work for the compressors 
	// 	has been satisfied:
	// 	Ideal_power_available = (Total enthalpy after satisifying compressor requirements) 
	// 	-  (Static enthaly after expanding gas to ambient pressure in an isentropic process)
	// 	\eta_{Thermal, ideal}  = Ideal_power_available/(fuel power)
		
	// 	// LP Shaft power efficiency
	// 	LP shaft power = (Power extracted by LP turbine - Power required by LPC)
	// 	This excludes the power that is put into the jet stream as it is expanded to ambient pressure
		
	// 	// Cycle Thermal Efficiency
	// 	Cycle net power  = (Total enthalpy after satisifying compressor requirements)
	// 	- (Static enthalpy after expaniding to amibent pressure through the nozzle (not isentorpic))
		
	// 	*/
	// 	real BypassKE, CoreKE;
	// 	real deltaKE, total_deltaKE, ThermalEff_ideal, ThermalEff_LPshaft, ThermalEff_cycle, ThermalEff_HPC, LP_PropEff, PropEff, OverallEff;	
	// 	//Flowstations
	// 	FlowStation Core_in, Core_out, LPC_in, LPT_in, LPT_core;
		
	// 	real ht_core_out, Pt_core_out, LPT_effpoly, cmp_pwr, gamma;
	// 	real LPT_pwr, net_pwr;
	// 	//Constants
	// 	real ftpers_TO_mpers = getUnitsFactor("ft/sec","m/sec");
	// 	real lbmpers_TO_kgpers = getUnitsFactor("lbm/sec","kg/sec");
	// 	real lbf_TO_N = getUnitsFactor("lbf","N");
	// 	real lbmhrlbf_TO_kgNs = getUnitsFactor("lbm/(hr*lbf)","kg/(N*sec)");
		
		
	// 	void postexecute() 
	// 	{ 
			
	// 		real fuelLHV = Eng.Core.FusPri.LHV*getUnitsFactor(Eng.Core.FusPri.LHV.units, "J/kg");
	// 		real fuelflow = Eng.Core.BrnPri.Wfuel*lbmpers_TO_kgpers;
			
	// 		cmp_pwr = Eng.CmpL.pwr * getUnitsFactor(Eng.CmpL.pwr.units, "W");
	// 		LPT_pwr = Eng.TrbL.pwr * getUnitsFactor(Eng.TrbL.pwr.units, "W");
	// 		net_pwr = LPT_pwr + cmp_pwr; // since Compressor power is negative
	// 		real ThermalEff_E = net_pwr/(fuelLHV*fuelflow);
			
	// 		//Copy the core flows and expand to ambient pressure to get ideal velocity
	// 		// LPC_in.W = Eng.CmpL.Fl_I.W; LPC_in.setTotal_hP(Eng.CmpF.Fl_I.ht, Eng.CmpF.Fl_I.Pt);
	// 		// THe above line tries to use the fan work too but then you need to calcualte the enthlpy rise
	// 		// and appropriately expand in the turbine (LPT) to get the imaginary flow station
			
	// 		LPC_in.copyFlow("Eng.CmpL.Fl_I");
	// 		LPC_in.setStaticPs(Amb.Ps);
			
			
	// 		LPT_in.copyFlow("Eng.TrbL.Fl_I"); gamma = LPT_in.gamt;
	// 		LPT_effpoly = Eng.TrbL.effPoly;
	// 		ht_core_out = LPT_in.ht*getUnitsFactor(LPT_in.ht.units, "J/kg") 
	// 						- (-cmp_pwr)/(LPT_in.W*lbmpers_TO_kgpers);
	// 		ht_core_out = ht_core_out*getUnitsFactor("J/kg", "Btu/lbm");
	// 		ht_core_out.units = "Btu/lbm";
	// 		Pt_core_out = LPT_in.Pt*(ht_core_out/LPT_in.ht)**(gamma/(LPT_effpoly*(gamma -1)));
	// 		Pt_core_out.units = LPT_in.Pt.units;
			
	// 		LPT_core.W = LPT_in.W; 
	// 		LPT_core.setTotal_hP(ht_core_out, Pt_core_out);
	// 		LPT_core.setStaticPs(Amb.Ps);
			
	// 		real KE_ideal = 0.5*(LPT_core.W*lbmpers_TO_kgpers*(LPT_core.V*ftpers_TO_mpers)**2);
			
	// 		ThermalEff_ideal = LPT_core.W*lbmpers_TO_kgpers*(LPT_core.ht - LPT_core.hs)*getUnitsFactor(LPT_in.hs.units, "J/kg") /(fuelLHV*fuelflow);
	// 		ThermalEff_LPshaft = LPT_core.W*lbmpers_TO_kgpers*(LPT_core.ht - Eng.TrbL.Fl_O.ht)*getUnitsFactor(LPT_in.hs.units, "J/kg") /(fuelLHV*fuelflow);
	// 		ThermalEff_cycle = LPT_core.W*lbmpers_TO_kgpers*(LPT_core.ht - Eng.NozPri.Fl_O.hs)*getUnitsFactor(LPT_in.hs.units, "J/kg") /(fuelLHV*fuelflow);
			
	// 		// cout<<"ideal "<<ThermalEff_ideal<<endl;
	// 		// cout<<"Neglect core jet "<<ThermalEff_LPshaft<<endl;
	// 		// cout<<"Neglect core jet "<<ThermalEff_cycle<<endl;

	// 		//----------------------------------------------
	// 		Core_in.copyFlow("Core.CmpH.Fl_I");  Core_in.setStaticPs(Amb.Ps);
	// 		Core_out.copyFlow("Core.TrbH.Fl_O"); Core_out.setStaticPs(Amb.Ps);
			
	// 		deltaKE = 0.5*(Core_out.W*lbmpers_TO_kgpers*(Core_out.V*ftpers_TO_mpers)**2 - 
	// 						Core_in.W*lbmpers_TO_kgpers*(Core_in.V*ftpers_TO_mpers)**2);
			
	// 		real KE_in = 0.5*(Eng.FsEng.W*lbmpers_TO_kgpers*(Amb.VTAS*getUnitsFactor(Amb.VTAS.units, "m/sec"))**2);
	// 		BypassKE = 0.5*(Eng.NozSec.Fl_O.W*lbmpers_TO_kgpers*(Eng.NozSec.Vactual*ftpers_TO_mpers)**2);
	// 		CoreKE = 0.5*(Eng.NozPri.Fl_O.W*lbmpers_TO_kgpers*(Eng.NozPri.Vactual*ftpers_TO_mpers)**2);
	// 		total_deltaKE = BypassKE + CoreKE - KE_in;
			
	// 		//Calculate thermal and propulsive efficiency
	// 		ThermalEff_HPC = deltaKE/(fuelLHV*fuelflow);
	// 		LP_PropEff = Eng.Perf.Fn*lbf_TO_N * Amb.VTAS*getUnitsFactor(Amb.VTAS.units, "m/sec") /deltaKE;
	// 		PropEff    = Eng.Perf.Fn*lbf_TO_N * Amb.VTAS*getUnitsFactor(Amb.VTAS.units, "m/sec") /total_deltaKE;
	// 		OverallEff = Amb.VTAS*getUnitsFactor(Amb.VTAS.units, "m/sec")/(fuelLHV*Perf.SFC*lbmhrlbf_TO_kgNs);
	// 	}
	// }


	// 8. Performance calculations
	//------------------------------
	// EngPerf Perf
	//------------------------------
    
	real Wtshaft, Weng, Webare, We1, Weadd;
	real rSnace, fpylon, Snace1, feadd;
	real IdealThermalEff, fancorework, LPCwork, NetWork;

	Element EngPerf Perf 
	{

        real Fn_total_N, FnSplit, Vin;
        real FgCore, FgFan, FfracCore, FfracFan, FfracPodProp;
        void postexecute()
		{ 
			//---------------------------------------------
            // Calculate thrust here:
			//---------------------------------------------
			// Gross thrusts:
				FgCore = NozPri.Fg;
				// FgCore = PCEC.Fl_O.V*PCEC.Fl_O.W/C_GRAVITY;
				real CoreFg = FgCore;
				// cout<<"Fgcore = "<<FgCore<<endl;
				// cout<<"Fgcore calc = "<<NozPri.Vactual*NozPri.Fl_O.W/C_GRAVITY<<endl;
				FgFan  = NozSec.Fg;
				Fg = FgCore + FgFan;
			//Ram drag:
				Fram     = InEng.Fram; //Ram drag from fan alone
				// cout<<"Fram = "<<Fram<<endl;
				// cout<<"Fram calc = "<<InEng.Fl_I.V*InEng.Fl_O.W/C_GRAVITY<<endl;

			// BLI "thrust"
				// Vin = InEng.Fl_I.V * getUnitsFactor(InEng.Fl_I.V.units, "m/sec" );
				// if(Vin > 0.0){
				// 	Finl = Phiinl/Vin;
				// }
            // Net thrust from Aft fans:
            // Fn = FgCore + FgFan - Fram + Finl*getUnitsFactor("N", "lbf");
			Fn = FgCore + FgFan - Fram;

            Fn_total_N = Fn*getUnitsFactor("lbf", "N");

            // FfracCore  = NozPri.Fg/Fg;
            FfracCore  = CoreFg/Fg;
            FfracFan   = NozSec.Fg/Fg;

            SFC = BrnPri.Wfuel*getUnitsFactor(BrnPri.Wfuel.units, "lbm/hr")/Fn_total_N*getUnitsFactor("lbf", "N");

            // cout<<FfracCore + FfracFan + FfracPodProp<<endl;

			//---------------------------------------------
			// Calculate weights
			//---------------------------------------------

			// Tshaft weight:
			//---------------------------------------------

			if (switchDes == "DESIGN")
			{

			// 45.605 kg/(kg/s) from Dowdle et al
			// alt. use 38.9 kg/(kg/s)from Hall et al. https://arc.aiaa.org/doi/pdf/10.2514/6.2018-3973
			Wtshaft = (CmpL.Fl_I.W/2.205)**1.2 * 45.605 * 9.81;

			// Alt. use SP based on existing engines:
			real SPtshaft;
			// SPtshaft = 10.4e3; // Based on the RR T406 (4.58 MW power output) power density = 10.4 kW/kg. 
			//   SPtshaft = 11.2e3; // The GE38 (~5 MW) has a power density of 11.2 kW/kg
			//   SPtshaft = 4.41e3; // Based of TP400
			// SPtshaft = 8.0e3; // Rough estimate based on LEAP1B (choked flow ~ 340m/s and Fn = 130 kN P = 1/2 Fn Vj; Mass = 2780 kg)
			// Wtshaft = 9.81*(Gen.ShP*getUnitsFactor("hp", "W")*Gen.nparallel)/SPtshaft;
			
			// ASK: This would be the same for both TE and TF, right?? 
			// Fan and nacelle weight:
			real Dfan = CmpF.dia*0.0254; // convert to m


            // real OPR = Eng.BrnPri.Fl_I.Pt/Eng.CmpF.Fl_I.Pt;

			real OPR = Eng.CmpH.Fl_O.Pt/Eng.InEng.Fl_I.Pt;

		
			real BPR = Eng.SpltFan.BPR;

            real dlcomp, HTRlc, Alc;

		    HTRlc = 0.6;

            Alc = CmpF.Fl_I.Aphy/(1+BPR);

			dlcomp = (((4.0*Alc)/(3.1415*(1.0-HTRlc**2.0)))**0.5)*0.0254; //convert to m

		

			real acon = 18.09   *BPR**2.0 + 476.9  *BPR + 701.3;
          	real bcon = 0.001077*BPR**2.0 - 0.03716*BPR + 1.190;
          	real ccon =  0.0              - 0.01058*BPR + 0.3259;

			real lb_N = 1.0/4.44822;

			real mdotc = Eng.FsEng.W/(2.205/1.0);

			We1 = (acon/lb_N) * (mdotc/45.35)**bcon * (OPR/40.0)**ccon;

			real numeng;

			numeng = 2.0;

			Webare = We1 * numeng;

			Snace1 = rSnace * 0.25 * 3.1415 * Dfan**2.0;


			real Ainlet = 0.4*Snace1;
			real Acowl  = 0.2*Snace1;
			real Aexh   = 0.4*Snace1;
            real Acore  = 3.1415*dlcomp*(3.0*dlcomp);


			real Wnace1 = 4.45*(Ainlet/0.3048**2.0) * (2.5+0.0238*Dfan/0.0254) +
                    4.45*(Acowl /0.3048**2.0) *  1.9 +
                    4.45*(Aexh  /0.3048**2.0) * (2.5+0.0363*Dfan/0.0254) +
					4.45*(Acore /0.3048**2) *  1.9;
			 
			real ARfan  = 3;   //Blade aspeect ratio
			real bladesolidity = 0.4; // Blade solidity c/s
			real ktech = 0.5 ;
			real Utip  = Dfan/2* (2 * PI * CmpF.Nmech/60);
			// # Sagerser 1971, NASA TM X-2406
			// # Note: The term "weight" in Sagerser1971 is actually mass
			real mfan = ktech*(135.0 * Dfan**2.7/sqrt(ARfan) * (bladesolidity/1.25)**0.3 * (Utip/350.0)**0.3);

            real Wnac = Wnace1 * numeng;
			 
			Weadd = Webare*feadd; 

			real Wpylon = (Webare + Weadd + Wnac)*fpylon;

            real Wtest;
			
			Weng = Webare + Weadd + Wnac + Wpylon;

			Wtshaft = Wtshaft*(1+feadd);
			// Weng = (mfan*9.81 + Wnace1*0.8)*(1+fpylon);
			}
			//---------------------------------------------
			// Calculate thermal eff
			//---------------------------------------------
			real fuelLHV  = FusEng.LHV*getUnitsFactor(FusEng.LHV.units, "J/kg");
			real fuelflow = BrnPri.Wfuel*getUnitsFactor(BrnPri.Wfuel.units,"kg/sec");

			fancorework = -CmpF.pwr/CmpF.Fl_O.W *CmpL.Fl_I.W * getUnitsFactor(Eng.CmpF.pwr.units, "W");
			LPCwork     = -CmpL.pwr * getUnitsFactor(Eng.CmpL.pwr.units, "W");
			NetWork  =  TrbL.pwr * getUnitsFactor(Eng.TrbL.pwr.units, "W") - LPCwork - fancorework;
			IdealThermalEff = NetWork/(fuelLHV*fuelflow);


        }


	}
	

	// ------------------------------
	// Cycle Parameters
	// ------------------------------
	
	// ASK: What is this??
	// Element Cycle Cycle
	// {
	// 	EPR_numName = "Core.Fl_O";
	// 	EPR_denName = "InEng.Fl_O";
	// 	FPR_numName = "CmpF.Fl_O";
	// 	FPR_denName = "InEng.Fl_O";
	// }

	
	// 9. Component linkages
	#include <../model/linkage.mdl>
	


	// 10. Solver settings

	//------------------------------------------------------------------------
	// Model Dependents & Independents
	//------------------------------------------------------------------------
	//  >>>> DESIGN CONDITIONS <<<<<<<
	
	//1,2 Turbine cooling Bleeds
	Independent ind_TCLA_NC_fracW { varName = "B030.TCLA_NC.fracW"; description = "Bleed flow"; }
	Independent ind_TCLA_CH_fracW { varName = "B030.TCLA_CH.fracW"; description = "Bleed flow"; }


	// 4 Fuel and Tt4
	Independent DESIGN_FUELFLOW { varName = "Eng.FusEng.Wfuel";	}
	Dependent DESIGN_TARGET_Tt41 { eq_lhs = "Eng.TrbH.F041.Tt"; eq_rhs = "Tt41";	}
	Dependent DESIGN_TARGET_NcFan { eq_lhs = "Eng.CmpF.NcPct"; eq_rhs = "100.0";	}


	// 5 Airflow Thrust
	Independent DESIGN_AIRFLOW  { varName = "Eng.FsEng.W_in"; }
	Dependent TARGET_THRUST { eq_lhs = "Eng.Perf.Fn_total_N"; eq_rhs = "Fn_target"; }
	

	// 8 BPR to target fansize
    Independent ind_BPR{varName = "Eng.SpltFan.BPRdes";}
    Dependent dep_Fandia{eq_lhs = "Eng.CmpF.dia"; eq_rhs = "61.0";}


	// 9 Fan shaft speed to target fan tip speed
	// Independent ind_FanSpeed{varName = "ShF.Nmech";}
	// Dependent dep_FanSpeed{eq_lhs = "CmpF.Mtip"; eq_rhs = "1.3";}

	// 10 Fan nozzle schedule 
	Independent ind_NozArea {varName = "Eng.NozSec.AthCold";}
	Dependent dep_CmpFNc{ eq_lhs = "Eng.CmpF.S_map.RlineMap"; eq_rhs="TB_NozArea(Eng.CmpF.S_map.NcMap)";}
	
	//------------------------------------------------------------------------
	//  >>>> OFF - DESIGN CONDITIONS <<<<<<<
	
	// vary nozzle area
	// Independent ind_NozArea { varName = "Eng.NozSec.AthCold"; }
	// // target Nozzle corrected speed matches Fan corrected speed
	// Dependent dep_CmpFNc { eq_lhs = "Eng.CmpF.S_map.RlineMap"; eq_rhs = "TB_NozzArea(Eng.CmpF.S_map.NcMap)"; }

	// use variableChanged method to change solver behaviour based on DESIGN or OFFDESIGN switchDes
	void variableChanged(string name, any oldval)
	{
		if (name == "switchDes")
		{
			if (switchDes == "DESIGN")
			{
				
				// Bleed Flows sizing ON
				ind_TCLA_NC_fracW.autoSetup = TRUE;
				ind_TCLA_CH_fracW.autoSetup = TRUE;;

				DESIGN_FUELFLOW.autoSetup = TRUE;
				DESIGN_TARGET_Tt41.autoSetup = TRUE;
				DESIGN_TARGET_NcFan.autoSetup = FALSE;

				DESIGN_AIRFLOW.autoSetup  = TRUE;
                TARGET_THRUST.autoSetup   = TRUE;

                ind_BPR.autoSetup    = TRUE;
                dep_Fandia.autoSetup = TRUE;

				// ind_FanSpeed.autoSetup = TRUE;
				// dep_FanSpeed.autoSetup = TRUE;

				ind_NozArea.autoSetup = FALSE;
				dep_CmpFNc.autoSetup  = FALSE;
				
			}
			else if (switchDes == "OFFDESIGN")
			{
				// Fixed Bleed flows
				ind_TCLA_NC_fracW.autoSetup = FALSE;
				ind_TCLA_CH_fracW.autoSetup = FALSE;
	
				// Offdesign Independents
				DESIGN_AIRFLOW.autoSetup  = FALSE; // W_in doesn't change but W changes based on operation
                TARGET_THRUST.autoSetup   = FALSE;

				DESIGN_FUELFLOW.autoSetup = TRUE;
				DESIGN_TARGET_Tt41.autoSetup = TRUE;
				DESIGN_TARGET_NcFan.autoSetup = FALSE;

                ind_BPR.autoSetup    = FALSE;
                dep_Fandia.autoSetup = FALSE;

				// ind_FanSpeed.autoSetup = FALSE;
				// dep_FanSpeed.autoSetup = FALSE;

				ind_NozArea.autoSetup = FALSE;
				dep_CmpFNc.autoSetup  = FALSE;
				
				

			}
		}
	}
	void OFFDES2(){

		setOption("switchDes", "OFFDESIGN");
      // Same setup as offdes but just swith out target Tt41 for target Fn
        TARGET_THRUST.autoSetup   = TRUE;
        DESIGN_TARGET_Tt41.autoSetup = FALSE;	


	}
}


// //-------------------------------------------------
// // Solver Settings
// //-------------------------------------------------

// presolverSequence = {"Eng.Amb" };//, "Eng.Guess" };
// setOption("switchDes","DESIGN");
// autoSolverSetup();

// // alter Eng assembly power setting mode
// Eng.Pset
// {
//     setOption("switchParm","THRUST");
//     setOption("switchLimitSet","NONE");
// }

// // 11. Bundle ESI handling with solver execution
// void run() {
// 	.errHandler.clear();
// 	execute();
// 	ESIpromote();
// 	.errHandler.clear();
// }
