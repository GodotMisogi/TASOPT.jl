//------------------------------------------------------------------------
//                                                                       |
//   File Name:     Tshaft.run                                           |
//   Date(s):       March 23rd , 2021                                    |
//   Author:        Prakash Prashanth                                    |
//                                                                       |
//   Description:   Turboshaft engine for integration with TAESOPT       |
//                 Combined des and offdes                               |
//------------------------------------------------------------------------

MODELNAME = "Turboshaft engine";
AUTHOR    = "Prashanth";

setThermoPackage("GasTbl");
#include "TShaft.mdl"
#include "printDetails.fnc"
#include "utils.fnc"
#include "save_solver.fnc"

// Define true and false to make it easier to use from Julia
// int true  = 1;
// int false = 0;

Eng.PCEC.setOption("switchMode", "ON");
//====================
// Solver setup:
//====================
solver.maxIterations = 200;
solver.maxJacobians  = 200;
// solver.debugLevel = "ITERATION_DETAILS";
// solver.diagnosticFile = "solver.diag";
// solver.solutionMode = "ONE_PASS";
// solver.defaultDxLimit = 0.001;
// solver.defaultPerturbation = 0.0001;
// solver.convergenceLimit = 0.8;
// solver.defaultTolerance = 1e-10;

//====================
// Outputs
//====================
OutFileStream output {
    filename = "Eng.output"; //autoFlush = FALSE;
}
// Set up a log file to track/ debug and just generally enjoy NPSS output
OutFileStream logfile{
    filename = "Tshaft.log";
}
CaseRowViewer Output {
    outStreamHandle = "logfile";
	titleBody = "???????????????????? \t run on: ?????????\t		at: ?????????? by: ??????\t Model Author: ??????????" ;
	titleVars = {"MODELNAME","date","timeOfDay","USER","AUTHOR"}		
	caseHeaderBody ="";
	caseHeaderVars = {}
    #include "TshaftDetails.lst"
    showHeaders = -1;
}
// postsolverSequence.append("Output");

int first;
int true  = 1;
int false = 0;
real ShP_input;
real Fn_target;
real deNOx_target, Tt41, N2_dmd;
int flag;
string inString;
real solverIndeps1[] = { 0.129679, 0.113856, 4.23255, 10.7817, 54.9322, 0.541746, 14.6579 }; // Design restart values
real solverIndeps2[] = { 18941.7, 0.684967, 66.5537, 0.226413, 2.0045, 2.95941, 5.02227, 36801.1, 30000 }; // OffDes1 restart values
real solverIndeps3[];

//---------------------------------------------
// Start looping: 
//---------------------------------------------
while(flag!=999){

    cin >> flag;
    if(flag == 999){
        break;
    }

    if(flag==111){
        flag = 0;
        inString = cin.getline();
        //====================
        //  Read input file
        //====================
        parseString(inString);
        Eng.setOption("switchDes","DESIGN");
        //====================
        //Auto solver setup
        //====================
        solver.clear();
        autoSolverSetup();

        //====================
        //  Run engine model
        //====================
        // restart("des.restart");
        // Include this here directly to save on IO costs:
        solver.independentNames = {"Eng.ind_TCLA_NC_fracW",
                                    "Eng.ind_TCLA_CH_fracW",
                                    "Eng.TrbH.S_map.ind_PRbase",
                                    "Eng.TrbP.S_map.ind_PRbase",
                                    "Eng.DESIGN_AIRFLOW",
                                    "Eng.DESIGN_FUELFLOW",
                                    "Eng.ind_Acat" };
        solver.independentValues = solverIndeps1;

        run();
        CASE++;

        //====================
        // Outputs
        //====================
        // MsgBlock1( "Number of Iterations to solve = "+toStr(solver.iterationCounter));
        if(solver.converged == 1){
            // SaveIndepVals("solver", "des.restart");
            solverIndeps1 = solver.independentValues;
            // output.reopen();
            // #include "write_des_output.int"
            // output.close();
            // cout<<"1";
            // #include "saveTShaftDes.fnc"
            // Write following outputs to outstream
            // eta_thermal, mdotf, BSFC, deNOx, mcat
            cout<<"1"<<"_"                                     // Success/ Failure indicator
            <<Eng.Perf.IdealThermalEff<<"_"
            <<Eng.FusEng.Wfuel/2.205<<"_"
            <<Eng.Perf.BSFC<<"_"
            <<Eng.PCEC.deNOx<<"_"
            <<Eng.PCEC.m_cat<<"_"
            <<Eng.BrnPri.EINOx<<"_"
            <<Eng.BrnPri.Fl_I.W/2.205<<"_"
            <<Eng.CmpH.Fl_O.Tt*100/180<<"_"
            <<Eng.CmpH.Fl_O.Pt/Eng.InEng.Fl_I.Pt<<"_"
            <<Eng.CmpH.Fl_O.Wc<<"_"
            <<Eng.FusEng.LHV<<"_"
            <<Eng.FsEng.Fl_O.W;

        }
        else{
            output.reopen();
            #include "write_des_output.int"
            output.close();
            // cout<<"ERROR! DES Did not converge"<<endl;
            cout<<"0"; // Tell's Julia that this didn't converge
        }


    }

    if(flag==222){
        flag = 0;
        inString = cin.getline();
        //====================
        //  Read input file
        //====================
        parseString(inString);
        Eng.setOption("switchDes","OFFDESIGN");
        //====================
        //Auto solver setup
        //====================
        solver.clear();
        autoSolverSetup();

        //====================
        //Run engine model
        //====================

        if(first){
            #include "Tshaft_design.int"
            // Eng.FusEng.LHV   = 18490;
            // restart("offdesTO.restart");
            solver.independentValues = solverIndeps2;
            // restart("offDes1.restart");
        }
        // else {
            // restart("offDes_fan_prev.restart");
            // restart("offDes1.restart");
        // }
        run();
        CASE++;

        //====================
        // Outputs
        //====================
        // MsgBlock1( "Number of Iterations to solve = "+toStr(solver.iterationCounter));
        if(solver.converged == 1){
            if(first){
                // SaveIndepVals("solver", "offDes1.restart");
                solverIndeps2 = solver.independentValues;
            }
            // output.reopen();
            // #include "write_offdes_output.int"
            // output.close();
            // cout<<"1";

            // Write following outputs to outstream
            // ShP, eta_thermal, mdotf, BSFC, deNOx 
            cout<<"1"<<"_"                                     // Success/ Failure indicator
            <<Eng.ShP.HPX*746<<"_"
            <<Eng.Perf.IdealThermalEff<<"_"
            <<Eng.FusEng.Wfuel/2.205<<"_"
            <<Eng.Perf.BSFC<<"_"
            <<Eng.PCEC.deNOx<<"_"
            <<Eng.NozPri.Fl_O.Tt*10/18<<"_"
            <<Eng.CmpH.Fl_O.Tt*100/180<<"_"
            <<Eng.CmpH.Fl_O.W<<"_"
            <<Eng.BrnPri.EINOx<<"_"
            <<Eng.BrnPri.FAR;
        }
        else{
            output.reopen();
            #include "write_offdes_output.int"
            output.close();
            cout<<"0"; // Tell's Julia that this didn't converge
            // cout<<"ERROR! OFFDES Did not converge"<<endl;
        }

    }

    if(flag==333){
        flag = 0;
        inString = cin.getline();
        //====================
        //  Read input file
        //====================
        parseString(inString);
        Eng.OFFDES2();
        //====================
        //Auto solver setup
        //====================
        solver.clear();
        autoSolverSetup();

        //====================
        //Run engine model
        //====================

        if(first){
            #include "Tshaft_design.int"
            // restart("offdesTO.restart");
            restart("offDes2.restart");
        }
        // else {
            // restart("offDes_fan_prev.restart");
            // restart("offDes1.restart");
        // }
        run();
        CASE++;

        //====================
        // Outputs
        //====================
        // MsgBlock1( "Number of Iterations to solve = "+toStr(solver.iterationCounter));
        if(solver.converged == 1){
            if(first){
                SaveIndepVals("solver", "offDes2.restart");
            }

            // Write following outputs to outstream
            // ShP, eta_thermal, mdotf, BSFC, deNOx 
            cout<<"1"<<"_"                                     // Success/ Failure indicator
            <<Eng.ShP.HPX*746<<"_"
            <<Eng.Perf.IdealThermalEff<<"_"
            <<Eng.FusEng.Wfuel/2.205<<"_"
            <<Eng.Perf.BSFC<<"_"
            <<Eng.PCEC.deNOx;
        }
        else{
            output.reopen();
            #include "write_offdes_output.int"
            output.close();
            cout<<"0"; // Tell's Julia that this didn't converge
            // cout<<"ERROR! OFFDES Did not converge"<<endl;
        }

    }

}

Output.display();