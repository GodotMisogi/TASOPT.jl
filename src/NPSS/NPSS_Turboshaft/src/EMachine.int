#ifndef __EMACHINE__
#define __EMACHINE__

#include <InterpIncludes.ncp>

class EMachine extends Element {

	// Documentation
	description = isA() + "is an electric machine that 
    can either generate electrical power from a shaft power input,
    or produce shaft power with an electric power input";
	
	// Normal variables
	//---------------------------------------------

	int nparallel{
		value = 1; IOstatus = INPUT;
		description = "Number of parallel machines";
	}
	//Inputs or Output
	real ShP {
		value = 10000;  IOstatus = INPUT;  units = HORSEPOWER;
		description = "Shaft power";
	}

	real omega{
		value = 1500; IOstatus = OUTPUT; units = "rad/sec";
		description = "Angular velocity";
	}

	real tm{
		value = 20e-3; IOstatus = INPUT; units = "m";
		description = "Magnet thickness";
	}

	real tt{
		value = 0.02; IOstatus = INPUT; units = "m";
		description = "Tooth thickness";
	}

	real wt{
		value = 0.005; IOstatus = INPUT; units = "m";
		description = "Tooth width";
	}
	


	// Fixed vars or constants
    int phases{
        value = 3; IOstatus = INPUT; units = NONE;
        description = "Number of phases";
    }
    
	int Nsp{
		value = 3; IOstatus = INPUT; units = NONE;
		description = "Number of slots per pole";
	}

	real M{
		value = 8.604e5; IOstatus = INPUT; units = "A/m";
		description = "Magnetization constant";

	}

	real Utipmax{
		value = 200; IOstatus = INPUT; units = "m/sec";
		description = "Max rotor tip speed";

	}

	real Twind {
		value = 90; IOstatus = INPUT; units = "dC";
		description = "Winding copper temp";
	}

	real mu0{
		value = 4*PI*1e-7; description = "Vacuum permeability ";
		units = "H/m"; IOstatus = "const"; 
		
	}
	real rhoair{
		value = 1.225; units = "kg/m3";
		description= "Air density";
	}
	real muair{
		value = 1.716e-5; units = "kg/(m*sec)";
		description= "Air viscosity";
	}

	real rhostat{
		value = 8200; description = "Stator density - Alnico 50 steel";
		units = "kg/m3"; IOstatus = INPUT;
	}
	real rhorot{
		value = 8200; description = "Rotor density - Alnico 50 steel";
		units = "kg/m3"; IOstatus = INPUT;
	}
	real rhomag{
		value = 7501; description = "Magnet density - Neodymium";
		units = "kg/m3"; IOstatus = INPUT;
	}
	real rhocond{
		value = 8930; description = "Conductor denisty";
		units = "kg/m3"; IOstatus = INPUT;
	}
	
	real resist{
		// value = 1.724e-8; units = "ohm*m"; 
		value = 1.754e-8; units = "ohm*m"; 
		description = "Conductor resistivity";
	}

	real ralpha{
		value = 0.00393; description = "temp coeff of resistivity";
	}

	real ke = 32.183e-6; //Eddy current loss coeff
	real kh = 10.664e-3; // Hysteresis loss coeff
	real alpha = 1.793;

	// Design parameters
	int p{
		value = 8; IOstatus = INPUT; units = NONE;
		description = "Pole pairs i.e Npoles/2";
	}

	real g{
		value = 2e-3; IOstatus = INPUT; units = "m";
		description = "Air gap thickness";
	}

	real kpf{
		value = 0.35; IOstatus = INPUT; units = NONE;
		description = "Slot packing factor";
	}

	real Js{
		value = 10e6; IOstatus = INPUT; units = "A/m2";
		description = "Current density";
	}
	real Bsat{
		value = 1.8;  IOstatus = INPUT; units= "Wb/m2";
		description = "Saturation Flux";
	}
	real Awiremin{
		value = 0.518e-6; units = "m2";
		description = "Min Wire Area - 20 AWG";
	}
	real tauMax{
		value = 110e6; units = "Pa";
		description = "max torsional shear stress";
	}
	

	
	//Outputs	
	real Nmech {
		value = 0; IOstatus = OUTPUT; units = RPM;
		description = "Generator shaft speed";
	}
	
	real trq {
		value = 0; IOstatus = OUTPUT; units = FT_LBF;
		description = "Torque supplied to the generator shaft";
	}

	real eff {
		value = 0; IOstatus = OUTPUT;
		description = "Efficiency";
	}
	real Islot {
		value = 0.; units = "A"; 
		description = "Slot current";
	}
	real sigmag {
		value = 0;  IOstatus = OUTPUT;  units = "N/m2";
		description = "Air-gap shear stress";
	}
	real Bgap {
		value = 0; IOstatus = OUTPUT; units = "Wb/m2";
		description = "Air-gap flux density";
	}
	real Bteeth {
		value = 0; IOstatus = OUTPUT; units = "Wb/m2";
		description = "Teeth flux density";
	}

	real Rph {
		value = 0; IOstatus = OUTPUT; units = "ohm";
		description = "Phase resistance";
	}

//Mass components
	real mrbi{
		value = 0.01; IOstatus = OUTPUT; units = "kg";
		description = "Rotor back iron mass";
	}
	real msbi{
		value = 0.01; IOstatus = OUTPUT; units = "kg";
		description = "Stator back iron mass";
	}
	real mteeth{
		value = 0.01; IOstatus = OUTPUT; units = "kg";
		description = "Teeth mass";
	}
	real mmag{
		value = 0.01; IOstatus = OUTPUT; units = "kg";
		description = "Magnet mass";
	}
	real mwind{
		value = 0.01; IOstatus = OUTPUT; units = "kg";
		description = "Winding mass";
	}
	real mshaft{
		value = 0.01; IOstatus = OUTPUT; units = "kg";
		description = "Shaft mass";
	}
	real mass{
		value = 0.01; IOstatus = OUTPUT; units = "kg";
		description = "Total mass";
	}
// Radii
	real Rri{
		value = 0.01; IOstatus = OUTPUT; units = "m";
		description = "Rotor inner radius";
	}
	real Rro{
		value = 0.01; IOstatus = OUTPUT; units = "m";
		description = "Rotor outer radius";
	}
	real Rg{
		value = 0.01; IOstatus = OUTPUT; units = "m";
		description = "Air-gap radius";
	}
	real Rt{
		value = 0.01; IOstatus = OUTPUT; units = "m";
		description = "Teeth radius";
	}
	real Rsi{
		value = 0.01; IOstatus = OUTPUT; units = "m";
		description = "Stator inner radius";
	}
	real Rso{
		value = 0.01; IOstatus = OUTPUT; units = "m";
		description = "Stator outer radius";
	}
	real Rshafti{
		value = 0.01; IOstatus = OUTPUT; units = "m";
		description = "Shaft inner radius";
	}
// Thicknesses
	real tr{
		value = 0.01; IOstatus = OUTPUT; units = "m";
		description = "Rotor thickness";
	}
	real ts{
		value = 0.01; IOstatus = OUTPUT; units = "m";
		description = "Stator thickness";
	}
	real lstk{
		value = 0.01; IOstatus = OUTPUT; units = "m";
		description = "Stack length";
	}
	real lambda{
		value = 0.01; IOstatus = OUTPUT; units = NONE;
		description = "width to pitch ratio of slot";
	}
	real f{
		value = 2e3; units = "Hz";
		description= "Electric f";
	}
	real Pelec{
		value = 0.0; IOstatus = OUTPUT; units = "W";
		description = "Electric power";
	}
	real V{
		value = 0.0; IOstatus = OUTPUT; units = "V";
		description = "Voltage";
	}

	real Ateeth, Aslots, Aslot;
	real Bsbi, Brbi;
	real let;
	real F_l; // force per unit length of motor;
	real Qohmic {
		value = 0; IOstatus = OUTPUT; units = "W";
	};
	real Qcore {
		value = 0; IOstatus = OUTPUT; units = "W";
	};
	real Qeddy  {
		value = 0; IOstatus = OUTPUT; units = "W";
	};
	real Qhys   {
		value = 0; IOstatus = OUTPUT; units = "W";
	};
	real Qwind  {
		value = 0; IOstatus = OUTPUT; units = "W";
	};
	real Qtotal {
		value = 0; IOstatus = OUTPUT; units = "W";
	};
	real Re, Cf;
	real SP;
	real N; // Number of turns

	// Option variables
	Option switchDes {
		allowedValues = { DESIGN, OFFDESIGN } ;
		description = "Determines if the element is in design or off-design mode";
		IOstatus = INPUT;
		rewritableValues = FALSE;
	}
	Option switchMode {
		allowedValues = { "MOTOR", "GENERATOR" } ;
		description = "Determines if the Emachine is a motor or a generator";
		IOstatus = INPUT;
		rewritableValues = FALSE;
	}
	// Ports
	ShaftOutputPort Sh_O {
		description = "Mechanical connection to the shaft";
	}
	
	// Sockets
	
	// variableChanged()
	void variableChanged(string name, any oldVal) {

	}
	
	// Engineering calculations
	void calculate() {

// Mass calcs
// Layout:
//		
//          +-------------------------------+     <----------------+
//          |        Stator back Iron       | }ts                  |
//          |   +--+   +--+   +--+   +--+   |     <------------+   |
//   Teeth  |   |  |   |  |   |  |   |  | wt| }tt              |   |
//          *---*  *---*  *---*  *---*  *---*     <--------+   |   |
// airgap {                                                |   |   |
//   (g)    +---------------+---------------+   ^ <----+   |   |   |
//          | Magnets       |               |   tm     |   |   |   |
//          |               |               |   v      |   |   |   |
//          +---------------+---------------+     <-+  |   |   |   |
//          |                               |   ^   |  |   |   |   |
//          |         Rotor back Iron       |   tr  |  |   |   |   |
//          |                               |   v   |  |   |   |   |
//          +-------------------------------+       |  |   |   |   |
//                                          ^       |  |   |   |   |
//                                          |       |  |   |   |   |
//                                          +       +  +   +   +   +
//                                         Rri    Rro  Rg  Rt  Rsi Rso

			Nmech = Sh_O.Nmech;
			omega = Nmech*2*PI/60;
			f= p*omega/2/PI;

		if (switchDes == DESIGN) {
			Bgap = mu0 * M * tm/ (tm + g);

			// All geometric calculations
			Rg  = Utipmax/omega;
			Rt  = Rg + g;
			Rro = Rg - tm;
			
			Bsbi = Bsat*0.98;
			Brbi = Bsat*0.98;
			tr = (Bgap/Brbi) * PI*Rg/(2*p);
			ts = (Bgap/Bsbi) * PI*Rg/(2*p);

			Rri = Rro - tr;
			Rsi = Rt  + tt;
			Rso = Rsi + ts;

			Ateeth = Nsp * 2*p*tt*wt;
			Aslots = PI*(Rt + Rsi)*tt - Ateeth;
			Aslot = Aslots/Nsp/2/p;

			lambda = Aslots/(Aslots + Ateeth);

			Bteeth = sqrt((Bgap/lambda)**2 + (mu0*Js*sqrt(2)*tt)**2);

			trq  = ShP*getUnitsFactor(ShP.units, "W")/omega * getUnitsFactor("N*m", trq.units);

			Islot = Js*kpf*Aslot;

			N = floor(kpf*Aslot/Awiremin);
			
			F_l = 4/3*Nsp*p * Bgap * Islot;
			lstk = trq * getUnitsFactor("ft*lbf", "N*m") /(F_l*Rg);

			let = PI/(2*p) *Rt* (lambda/sqrt(1-lambda**2)); //endturns length

			real TRV = trq * getUnitsFactor("ft*lbf", "N*m") / (PI*(Rg**2 - Rri**2)*lstk);
			sigmag = TRV/2;

			//Mass calculations:
			mrbi = PI*(Rro**2 - Rri**2)*lstk * rhorot ;
			msbi = PI*(Rso**2 - Rsi**2)*lstk * rhostat;
			mmag = PI*( Rg**2 - Rro**2)*lstk * rhomag ;
			mteeth = Ateeth * lstk * rhostat;
			mwind  = kpf*Aslots*(lstk + 2*let)*rhocond + (1-kpf)*Aslots*(lstk + 2*let)*1700;
			//Size shaft
			Rshafti = (Rri**4.0 - trq*getUnitsFactor("ft*lbf", "N*m")/(tauMax/1.2) * 2*Rri/PI)**(0.25);
			if(isNaN(Rshafti)){
				Rshafti = 0.0;
			}
			mshaft  = PI*(Rri**2 - Rshafti**2)*lstk*1.2*rhostat;

			mass   = mrbi + msbi + mmag + mteeth + mwind + mshaft;

			// Resistance
			Rph = Nsp/phases * 2*p* resist *( 1 + ralpha*(Twind - 20))* (lstk + 2*let)/(kpf*Aslot);

			SP = ShP * getUnitsFactor(ShP.units, "kW")/mass;
			
			// cout<<"SP = "<<SP<<endl;
			// cout<<"freq ="<<f<<endl;
			// cout<<"Trq = "<<trq * getUnitsFactor(trq.units, "N*m")<<endl;
			// cout<<"Pwr = "<<ShP * getUnitsFactor(ShP.units, "MW")<<endl;
			// cout<<"Sigma = "<<sigmag<<endl;
			// cout<<"Bgap ="<<Bgap<<endl;
			// cout<<omega*Rg<<endl;

		}

		trq  = ShP*getUnitsFactor(ShP.units, "W")/omega * getUnitsFactor("N*m", trq.units);
		// Calculate Islot, freq and B
		Qohmic = Islot**2 * (2*Rph);
		Qeddy  = getUnitsFactor("kg", "lbm") * ( msbi*(ke* f**2 * Bsbi**2    ) + mteeth*(ke * f**2 * Bteeth**2    ) ); // frm Eqns 3.38 and 3.39 of Ofori-Tenkorang's Thesis
		Qhys   = getUnitsFactor("kg", "lbm") * ( msbi*(kh* f    * Bsbi**alpha) + mteeth*(kh * f    * Bteeth**alpha) );
		Qcore  = Qeddy + Qhys;

// CHECK these:
		Re = omega * Rg * g * rhoair/muair;
		// Re = omega * Rg * 2*PI*Rg * rhoair/muair;
		Cf = 0.0725*Re**(-0.2);
		// Cf = 1.33*Re**(-0.5);
		Qwind  = Cf*PI*rhoair*(omega)**3 * Rg**4*lstk; 
		// Qwind = 2*PI*Rg*lstk * (omega*Rg)**2 * muair/g;

		Qtotal = Qohmic + Qeddy + Qhys + Qwind;

		if (switchMode == "MOTOR"){
			// Input electric power, outputs shaft power => Pelec > Pshaft
			Pelec = ShP*getUnitsFactor(ShP.units, "W") + Qtotal;
			eff   = (ShP*getUnitsFactor(ShP.units, "W"))/Pelec;
			Sh_O.trq = +1*trq*nparallel; //Adds work to shaft
		}
		else {
			// Input shaft power, outputs electric power => Pelec < Pshaft
			Pelec = ShP*getUnitsFactor(ShP.units, "W") - Qtotal;
			eff   = Pelec/(ShP*getUnitsFactor(ShP.units, "W"));
			Sh_O.trq = -1*trq*nparallel; //Removes work from shaft
		}

		V = Pelec/Islot * PI/2/phases;
		real tdi = V/1e7;


		
		// cout<<"V = "<<V<<endl;
		// cout<<"tdi = "<<tdi<<endl;
		// cout<<"Eff = "<<eff*100<<"%"<<endl;
		// cout<<"Pelec = "<<Pelec<<endl;
		// cout<<"Qtotal = "<<Qtotal<<endl;
		// cout<<"Split ratio = "<<sqrt((Rg**2 - Rri**2)/(Rso**2 - Rsi**2))<<endl;
		// cout<<"Aspect ratio = "<<lstk/(2*Rg)<<endl;

	}
}
#endif